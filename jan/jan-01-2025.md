# Day 1, Jan 01, 2025

- Objective: Convert format2 data to format3 data and put in .ods

## Notes
1. format2 movie, show, episode have different params but format3 has the same param list. movie, show, episode becomes a single class, entertainment.

## Converting Movie from format2 to format3

- format2
    ```
    Movie {
        id: int
        type: String
        franchise: String
        title: String
  
        status: int[]
        tags: String[]
  
        duration: int
        date: Local Date
        productionCompanies: String[]
    }
    ```

- format3
    ```
    Movie {
        id: int
        name: String -> visualName(franchise, title)
        type: String
        date: Local Date
  
        status: String
        isSpecial
        isPilot
        isFavorite
  
        tags: String[15]
        duration: int
    }
    ```

## Convertor
1. Read format2_datafile.txt
2. get visualName() method from last 'entertainment tracker project'
3. convert movie data to format3
4. convert show data to format3
5. convert episode data to format3
6. 

### Visual Name Convertor
```java
/**
 * format2: franchise + title via visualName :: 2 vars
 * format3: name (format2 visualName) :: 1 var
 * @param franchise first part of movie/show name
 * @param title second part of movie/show  name
 * @return the correct full name of show/movie
 */
public static String visualName(String franchise, String title) {
    if (title == null || title.isEmpty() || title.equals("NVR")) return franchise;
    else if (franchise.contains("**")) return (franchise.replace("**", " ") + title);
    else return (franchise + ": " + title);
}
```

### format2 Status Mapping
Used format2 data (only format of data available) to figure out mapping.
 - 1 > Completed (Primary)
 - 2 > Released (Primary)
 - 3 > Upcoming (Primary)
 - 4 > Special (Secondary)
 - 5 > Pilot (Secondary)
 - 6 > Favorite (Secondary)
 - 7 > 
 - 8 > 
 - 9 > Ongoing (Primary)

### format3
two ways to store status:
1. Type 1
    ```
        status (1,2,3,9)
        booleans: isSpecial (4), isPilot (5), isFavorite (6)
    ```
   1. Cols: 4
   2. Parsing: No


2. Type 2
    ```
        status-isSpecial-isPilot-isFavorite
        ex: 1-1-0-1, 9-0-1-0
    ```
   1. Cols: 1
   2. Parsing: Yes

Result: Type 1. SQL searching easier when porting to SQLite from ODS.

## Converting Show from format2 to format3

- format2
    ```
    Show {
        id: int
        type: String
        franchise: String
        title: String
  
        status: int[]
        tags: String[]
  
        seasonNum: int
        episodeCount
        date: LocalDate
        seasonId: int
    }
    ```

- format3
    ```
    Show {
        id: int
        name: String -> visualName(franchise, title)
        type: String
        date: Local Date
        
        status: String
        isSpecial
        isPilot
        isFavorite
  
        tags: String[15]
        seasonId: int
    }
    ```



## Converting Episode from format2 to format3

- format2
    ```
    Episode {
        id: int
        type: String
        episodeNum: String
        name: String
  
        status: int[]
        tags: String[]
  
        duration: int
        date: LocalDate
        seasonId: int
    }
    ```

- format3
    ```
    Episode {
        id: int
        name: String -> visualName(franchise, title)
        type: String
        date: Local Date
        
        status: String
        isSpecial
        isPilot
        isFavorite
  
        tags: String[15]
        seasonId: int
        episodeNum: int
        duration: int
    }
    ```

## format3: Entertainment
this class will be sole responsible to hold all movie, show and episode data in a single data class.
```
Entertainment {
    id: int
    name: String -> visualName(franchise, title)
    type: String
    date: Local Date
    
    status: String
    isSpecial
    isPilot
    isFavorite

    tags: String[15]
    
    seasonId: int
    episodeNum: int
    duration: int
}
```

## Mapping format3
mapping movie, show, episode to entertainment

| Entertainment |       Movie        |        Show        |      Episode       |
|:-------------:|:------------------:|:------------------:|--------------------|
|      id       | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|     name      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|     type      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|     date      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|    status     | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   isSpecial   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|    isPilot    | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|  isFavorite   | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|     tags      | :white_check_mark: | :white_check_mark: | :white_check_mark: |
|   seasonId    |        :x:         | :white_check_mark: | :white_check_mark: |
|  episodeNum   |        :x:         |        :x:         | :white_check_mark: |
|   duration    | :white_check_mark: |        :x:         | :white_check_mark: |

## AI Stuff

to get my fields from record class, we have this method from AI
```java
// I did not write this
private static Object getProperty(Object obj, String fieldName) {
    try {
        return obj.getClass().getMethod(fieldName).invoke(obj);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        e.printStackTrace();
        return null;
    }
}
```



